include: "classpath:/common.methods.yml"

COLOR_OUT:
  C: |
    void ColorOut(int column, int row, int color) {
        switch(color) {
            case 1:
                TextOut(column, row, "Black");
                break;
            case 2:
                TextOut(column, row, "Blue");
                break;
            case 3:
                TextOut(column, row, "Green");
                break;
            case 4:
                TextOut(column, row, "Yellow");
                break;
            case 5:
                TextOut(column, row, "Red");
                break;
            case 6:
                TextOut(column, row, "White");
                break;
            case 7:
                TextOut(column, row, "Magenta");
                break;
            case 8:
                TextOut(column, row, "Orange");
                break;
            case 9:
                TextOut(column, row, "Lime");
                break;
            case 10:
                TextOut(column, row, "Violet");
                break;
            case 11:
                TextOut(column, row, "Crimson");
                break;
            case 12:
                TextOut(column, row, "Purple");
                break;
            case 13:
            case 14:
            case 15:
            case 16:
            case 17:
                TextOut(column, row, "White");
                break;
            default:
                TextOut(column, row, "Grey");
                break;
        }
    }

BOOL_OUT:
  C: |
    void BoolOut(int column, int row, bool boolean) {
        if (boolean) {
            TextOut(column, row, "true");
        } else {
            TextOut(column, row, "false");
        }
    }

POWER:
  C: |
    inline float MathPow(float firstValue, float secondValue) {
        float result = 1;
        for (int i = 0; i < abs(secondValue); i++) {
            result = result * firstValue;
        }
        if (secondValue < 0) {
            if (firstValue == 0) {
                return NULL;
            } else {
                return 1 / result;
            }
        } else {
            return result;
        }
    }

ROUNDDOWN:
  C: |
    inline int MathFloor(float val) {
        int temp = val;
        return temp;
    }

ROUND:
  C: |
    inline int MathRound(float val) {
        return MathFloor(0.5 + val);
    }

ROUNDUP:
  C: |
    inline int MathRoundUp(float val) {
        return (1 + MathFloor(val));
    }

WHOLE:
  C: |
    inline bool MathIsWhole(float val) {
        int intPart = val;
        return ((val - intPart) == 0);
    }

PRIME:
  C: |
    inline bool MathPrime(float number) {
        if ((number % 2 == 0) || (number == 1)) return false;
        //if not, then just check the odds
        for (int i = 3; i * i <= number; i += 2) {
            if (number % i == 0)
                return false;
        }
        return true;
    }

LN:
  C: |
    inline float MathLn(float val) {
        if (val > 1) {
            float values[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 200, 300, 400, 500, 600, 700, 800, 900, 1000, 10000};
            float results[] = {0, 0.693147, 1.098612, 1.386294, 1.609438, 1.791759, 1.945910, 2.079442, 2.197225, 2.302585, 2.995732, 3.401197, 3.688879, 3.912023, 4.094345, 4.248495, 4.382027, 4.499810, 4.605170, 5.298317, 5.703782, 5.991465, 6.214608, 6.396930, 6.551080, 6.684612, 6.802395, 6.907755, 9.210340};
            int i = 1;
            while (values[i] < abs(val)) {
                i++;
            }
            float result = results[i - 1] + (abs(val) - values[i - 1]) * (results[i] - results[i - 1]) / (values[i] - values[i - 1]);
            if (val <= 100000) {
                return result;
            } else {
                return 9.22;
            }
        } else if ((val > 0) && (val <= 1)) {
            float summ = 0;
            for (int n = 1; n < 10; n++) {
                summ += MathPow(-1, (n + 1)) * MathPow((val - 1), n) / n;
            }
            return summ;
        } else {
            TextOut(0, LCD_LINE1, "invalid value");
            Wait(1000);
            ClearScreen();
            return NULL;
        }
    }

LOG10:
  C: |
    inline float MathLog(float val) {
        return MathLn(val) / MathLn(2.71828);
    }

FACTORIAL:
  C: |
    inline float MathFactorial(float val) {
        float result = val;
        if (val == 0) {
            return 1;
        } else {
            for (int i = 1; i < val; i++) {
                result = result * (val - i);
            }
            return result;
        }
    }

SIN:
  C: |
    inline float MathSin(float val) {
        float angle = PI * val / 180;
        float summ = 0;
        for (int n = 0; n < 10; n++) {
            summ += MathPow(-1, n) * MathPow(angle, (2 * n + 1)) / MathFactorial(2 * n + 1);
        }
        return summ;
    }

COS:
  C: |
    inline float MathCos(float val) {
        float angle = PI * val / 180;
        float summ = 0;
        for (float n = 0; n < 10; n++) {
            summ += (MathPow(-1, n) / MathFactorial(2 * n)) * MathPow(angle, (2 * n));
        }
        return summ;
    }

TAN:
  C: |
    inline float MathTan(float val) {
        return MathSin(val) / MathCos(val);
    }

ASIN:
  C: |
    inline float MathAsin(float val) {
        if (abs(val) > 1) {
            TextOut(0, LCD_LINE1, "invalid value");
            Wait(1000);
            ClearScreen();
            return NULL;
        } else {
            float summ = 0;
            for (float n = 0; n < 15; n++) {
                summ += MathFactorial(2 * n) * MathPow(val, (2 * n + 1)) / MathPow(4, n) / MathPow(MathFactorial(n), 2) / (2 * n + 1);
            }
            return summ * 180 / PI;
        }
    }

ACOS:
  C: |
    inline float MathAcos(float val) {
        if (abs(val) > 1) {
            TextOut(0, LCD_LINE1, "invalid value");
            Wait(1000);
            ClearScreen();
            return NULL;
        } else {
            return 90 - MathAsin(val);
        }
    }

ATAN:
  C: |
    inline float MathAtan(float val) {
        if (abs(val) > 1) {
            float values[] = {1, sqrt(3), 2, 3, 0x7f800000};
            float results[] = {45, 60, 63.435, 71.565, 90};
            int i = 1;
            while (values[i] < abs(val)) {
                i++;
            }
            float result = results[i - 1] + (abs(val) - values[i - 1]) * (results[i] - results[i - 1]) / (values[i] - values[i - 1]);
            if (val > 0) {
                return result;
            } else {
                return -result;
            }
        } else {
            float summ = 0;
            for (float n = 1; n < 15; n++) {
                summ += MathPow(-1, (n - 1)) * MathPow(val, (2 * n - 1)) / (2 * n - 1);
            }
            return summ * 180 / PI;
        }
    }

SUM:
  C: |
    inline float ArrSum(float arr[]) {
        float sum = 0;
        for (int i = 0; i < ArrayLen(arr); i++) {
            sum += arr[i];
        }
        return sum;
    }

MIN:
  C: |
    inline float ArrMin(float arr[]) {
        float min = arr[0];
        for (int i = 1; i < ArrayLen(arr); i++) {
            if (arr[i] < min) {
                min = arr[i];
            }
        }
        return min;
    }

MAX:
  C: |
    inline float ArrMax(float arr[]) {
        float max = arr[0];
        for (int i = 1; i < ArrayLen(arr); i++) {
            if (arr[i] > max) {
                max = arr[i];
            }
        }
        return max;
    }

IDTY:
  C: |
    inline int idty(int id) {
        return id;
    }

AVERAGE:
  C: |
    inline float ArrMean(float arr[]) {
        float sum = 0;
        for (int i = 0; i < ArrayLen(arr); i++) {
            sum += arr[i];
        }
        return sum / idty(ArrayLen(arr));
    }

INSERTION_SORT:
  C: |
    inline void ArrInsertionSort(float& arr[]) {
        for (int i = 1; i < ArrayLen(arr); i++) {
            int index = arr[i];
            int j = i;
            while (j > 0 && arr[j - 1] > index) {
                arr[j] = arr[j - 1];
                j--;
            }
            arr[j] = index;
        }
    }

MEDIAN:
  C: |
    inline float ArrMedian(float arr[]) {
        int n = idty(ArrayLen(arr));
        if (n == 0) {
            return 0;
        }
        ArrInsertionSort(arr);
        float median;
        if (n % 2 == 0) {
            median = (arr[n / 2] + arr[n / 2 - 1]) / 2;
        } else {
            median = arr[n / 2];
        }
        return median;
    }

STD_DEV:
  C: |
    inline float ArrStandardDeviatioin(float arr[]) {
        int n = idty(ArrayLen(arr));
        if (n == 0) {
            return 0;
        }
        float variance = 0;
        float mean = ArrMean(arr);
        for (int i = 0; i < ArrayLen(arr); i++) {
            variance += MathPow(arr[i] - mean, 2);
        }
        variance /= n;
        return sqrt(variance);
    }

MODE:
  C: |
    inline float ArrMode(float arr[]) {
        ArrInsertionSort(arr);
        float element = arr[0];
        float max_seen = element;
        int count = 1;
        int mode_count = 1;
        for (int i = 1; i < ArrayLen(arr); i++) {
            if (arr[i] == element) {
                count++;
                if (count > mode_count) {
                    mode_count = count;
                    max_seen = element;
                }
            } else {
                element = arr[i];
                count = 1;
            }
        }
        return max_seen;
    }

FIND_FIRST_NUM:
  C: |
    inline int ArrFindFirstNum(float arr[], float item) {
        int i = 0;
        if (arr[0] == item) {
            return i;
        } else {
            do {
                i++;
            } while ((arr[i] != item) && (i != idty(ArrayLen(arr))));
            return i;
        }
    }

FIND_LAST_NUM:
  C: |
    inline int ArrFindLastNum(float arr[], float item) {
        int i = 0;
        if (arr[idty(ArrayLen(arr)) - 1] == item) {
            return idty(ArrayLen(arr)) - 1 - i;
        } else {
            do {
                i++;
            } while ((arr[idty(ArrayLen(arr)) - 1 - i] != item) && (i != 0));
            return idty(ArrayLen(arr)) - 1 - i;
        }
    }

FIND_FIRST_STR:
  C: |
    inline int ArrFindFirstStr(string arr[], string item) {
        int i = 0;
        if (arr[0] == item) {
            return i;
        } else {
            do {
                i++;
            } while ((arr[i] != item) && (i != idty(ArrayLen(arr))));
            return i;
        }
    }

FIND_LAST_STR:
  C: |
    inline int ArrFindLastStr(string arr[], string item) {
        int i = 0;
        if (arr[idty(ArrayLen(arr)) - 1] == item) {
            return idty(ArrayLen(arr)) - 1 - i;
        } else {
            do {
                i++;
            } while ((arr[idty(ArrayLen(arr)) - 1 - i] != item) && (i != 0));
            return idty(ArrayLen(arr)) - 1 - i;
        }
    }

FIND_FIRST_BOOL:
  C: |
    inline int ArrFindFirstBool(bool arr[], bool item) {
        int i = 0;
        if (arr[0] == item) {
            return i;
        } else {
            do {
                i++;
            } while ((arr[i] != item) && (i != idty(ArrayLen(arr))));
            return i;
        }
    }

FIND_LAST_BOOL:
  C: |
    inline int ArrFindLastBool(bool arr[], bool item) {
        int i = 0;
        if (arr[idty(ArrayLen(arr)) - 1] == item) {
            return idty(ArrayLen(arr)) - 1 - i;
        } else {
            do {
                i++;
            } while ((arr[idty(ArrayLen(arr)) - 1 - i] != item) && (i != 0));
            return idty(ArrayLen(arr)) - 1 - i;
        }
    }

SANITISE_FROM_START:
  C: |
    int sanitiseFromStart(int array_length, int index) {
        if (index >= 0 && index < array_length) {
            return index;
        } else {
            TextOut(0, (MAXLINES - 1) * MAXLINES, "Index out of bounds: ");
            NumOut(0, (MAXLINES - 2) * MAXLINES, index);
            TextOut(0, (MAXLINES - 1) * MAXLINES, "Press enter to continue.");
            while (true) {
                if (ButtonPressed(BTNCENTER, false) == true) {
                    Stop(true);
                }
                Wait(15);
            }
        }
    }

SANITISE_FROM_END:
  C: |
    int sanitiseFromEnd(int array_length, int from_end) {
        int index = array_length - from_end;
        if (index >= 0 && index < array_length) {
            return index;
        } else {
            TextOut(0, (MAXLINES - 1) * MAXLINES, "Index out of bounds: ");
            NumOut(0, (MAXLINES - 2) * MAXLINES, index);
            TextOut(0, (MAXLINES - 1) * MAXLINES, "Press enter to continue.");
            while (true) {
                if (ButtonPressed(BTNCENTER, false) == true) {
                    Stop(true);
                }
                Wait(15);
            }
        }
    }
